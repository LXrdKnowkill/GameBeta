/**
 * GameUI - Gerencia toda a interface do usu√°rio do jogo
 * Inclui barra de casting, HUD de informa√ß√µes e feedback visual
 */

/**
 * Classe respons√°vel por gerenciar todos os elementos de UI do jogo
 * Mant√©m refer√™ncias aos elementos HTML e fornece m√©todos para atualiz√°-los
 */
export class GameUI {
    // Elementos da barra de casting
    private castingBar!: HTMLElement;
    private castingProgress!: HTMLElement;
    private castingText!: HTMLElement;
    
    // Elementos de status do jogador
    private manaDisplay!: HTMLElement;
    private spellCount!: HTMLElement;
    
    // Estado da UI
    private isCastingBarVisible: boolean = false;

    constructor() {
        this.initializeElements();
        console.log('üñ•Ô∏è Sistema de UI inicializado!');
    }

    /**
     * Inicializa e obt√©m refer√™ncias para todos os elementos HTML
     */
    private initializeElements(): void {
        // Elementos da barra de casting
        this.castingBar = this.getElement('castingBar');
        this.castingProgress = this.getElement('castingProgress');
        this.castingText = this.getElement('castingText');
        
        // Elementos de status
        this.manaDisplay = this.getElement('manaDisplay');
        this.spellCount = this.getElement('spellCount');
        
        // Verificar se todos os elementos foram encontrados
        this.validateElements();
        
        console.log('‚úÖ Elementos de UI carregados com sucesso!');
    }

    /**
     * Obt√©m um elemento HTML pelo ID com verifica√ß√£o de erro
     */
    private getElement(id: string): HTMLElement {
        const element = document.getElementById(id);
        if (!element) {
            throw new Error(`Elemento HTML com id="${id}" n√£o encontrado!`);
        }
        return element;
    }

    /**
     * Valida se todos os elementos essenciais est√£o presentes
     */
    private validateElements(): void {
        const requiredElements = [
            { element: this.castingBar, name: 'castingBar' },
            { element: this.castingProgress, name: 'castingProgress' },
            { element: this.castingText, name: 'castingText' },
            { element: this.manaDisplay, name: 'manaDisplay' },
            { element: this.spellCount, name: 'spellCount' }
        ];

        for (const { element, name } of requiredElements) {
            if (!element) {
                console.error(`‚ùå Elemento ${name} n√£o encontrado na UI!`);
            }
        }
    }

    // === M√âTODOS DA BARRA DE CASTING ===

    /**
     * Mostra a barra de casting
     */
    public showCastingBar(): void {
        if (this.isCastingBarVisible) return;
        
        console.log('üìä Mostrando barra de casting...');
        
        this.castingBar.style.display = 'block';
        this.castingProgress.style.width = '0%';
        this.castingText.textContent = 'Conjurando...';
        this.isCastingBarVisible = true;
        
        // Anima√ß√£o de entrada suave
        this.castingBar.style.opacity = '0';
        setTimeout(() => {
            this.castingBar.style.transition = 'opacity 0.2s ease';
            this.castingBar.style.opacity = '1';
        }, 10);
    }

    /**
     * Esconde a barra de casting
     */
    public hideCastingBar(): void {
        if (!this.isCastingBarVisible) return;
        
        console.log('üìä Escondendo barra de casting...');
        
        // Anima√ß√£o de sa√≠da suave
        this.castingBar.style.transition = 'opacity 0.2s ease';
        this.castingBar.style.opacity = '0';
        
        setTimeout(() => {
            this.castingBar.style.display = 'none';
            this.isCastingBarVisible = false;
        }, 200);
    }

    /**
     * Atualiza o progresso da barra de casting
     * @param progress Valor entre 0.0 e 1.0 representando o progresso
     */
    public updateCastingProgress(progress: number): void {
        if (!this.isCastingBarVisible) return;
        
        // Garantir que o progresso est√° entre 0 e 1
        progress = Math.max(0, Math.min(1, progress));
        
        // Atualizar largura da barra
        const percentage = Math.floor(progress * 100);
        this.castingProgress.style.width = `${percentage}%`;
        
        // Atualizar texto baseado no progresso
        if (progress < 0.2) {
            this.castingText.textContent = 'Conjurando...';
        } else if (progress < 0.8) {
            this.castingText.textContent = 'Focando...';
        } else if (progress < 1.0) {
            this.castingText.textContent = 'Quase pronto...';
        } else {
            this.castingText.textContent = 'Pronto!';
        }
        
        // Mudar cor da barra baseado no progresso
        if (progress < 0.5) {
            // Come√ßar com azul claro
            this.castingProgress.style.background = 'linear-gradient(90deg, #4a90e2, #7bb3f0)';
        } else if (progress < 0.8) {
            // Meio termo - azul mais intenso
            this.castingProgress.style.background = 'linear-gradient(90deg, #2e7bc6, #4a90e2)';
        } else {
            // Quase completo - azul brilhante com toque dourado
            this.castingProgress.style.background = 'linear-gradient(90deg, #1e5f96, #ffd700)';
        }
    }

    // === M√âTODOS DE STATUS ===

    /**
     * Atualiza a exibi√ß√£o de mana
     * @param current Mana atual
     * @param max Mana m√°xima
     */
    public updateMana(current: number, max: number): void {
        if (!this.manaDisplay) return;
        
        const currentInt = Math.floor(current);
        this.manaDisplay.textContent = `${currentInt}/${max}`;
        
        // Mudar cor baseado na porcentagem de mana
        const percentage = current / max;
        if (percentage > 0.6) {
            this.manaDisplay.style.color = '#4a90e2'; // Azul normal
        } else if (percentage > 0.3) {
            this.manaDisplay.style.color = '#f0ad4e'; // Laranja (aten√ß√£o)
        } else {
            this.manaDisplay.style.color = '#d9534f'; // Vermelho (cr√≠tico)
        }
    }

    /**
     * Atualiza o contador de magias lan√ßadas
     * @param count N√∫mero de magias lan√ßadas
     */
    public updateSpellCount(count: number): void {
        if (!this.spellCount) return;
        
        this.spellCount.textContent = count.toString();
        
        // Pequena anima√ß√£o quando o n√∫mero aumenta
        this.spellCount.style.transform = 'scale(1.2)';
        this.spellCount.style.transition = 'transform 0.2s ease';
        
        setTimeout(() => {
            this.spellCount.style.transform = 'scale(1)';
        }, 200);
    }

    // === SISTEMA DE NOTIFICA√á√ïES ===

    /**
     * Mostra uma notifica√ß√£o tempor√°ria na tela
     * @param message Mensagem a ser exibida
     * @param type Tipo da notifica√ß√£o ('info', 'success', 'warning', 'error')
     * @param duration Dura√ß√£o em milissegundos (padr√£o: 3000)
     */
    public showNotification(
        message: string, 
        type: 'info' | 'success' | 'warning' | 'error' = 'info', 
        duration: number = 3000
    ): void {
        console.log(`üì¢ Notifica√ß√£o: ${message}`);
        
        // Criar elemento de notifica√ß√£o
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        
        // Estilos da notifica√ß√£o
        notification.style.position = 'fixed';
        notification.style.top = '100px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.color = 'white';
        notification.style.fontWeight = 'bold';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        
        // Cores baseadas no tipo
        switch (type) {
            case 'success':
                notification.style.backgroundColor = 'rgba(92, 184, 92, 0.9)';
                break;
            case 'warning':
                notification.style.backgroundColor = 'rgba(240, 173, 78, 0.9)';
                break;
            case 'error':
                notification.style.backgroundColor = 'rgba(217, 83, 79, 0.9)';
                break;
            default: // info
                notification.style.backgroundColor = 'rgba(74, 144, 226, 0.9)';
        }
        
        // Adicionar ao DOM
        document.body.appendChild(notification);
        
        // Anima√ß√£o de entrada
        setTimeout(() => {
            notification.style.opacity = '1';
        }, 10);
        
        // Remover ap√≥s dura√ß√£o especificada
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, duration);
    }

    // === M√âTODOS UTILIT√ÅRIOS ===

    /**
     * Atualiza√ß√£o geral da UI (chamada no loop principal)
     * @param deltaTime Tempo desde o √∫ltimo frame
     */
    public update(_deltaTime: number): void {
        // Por enquanto n√£o h√° atualiza√ß√µes cont√≠nuas necess√°rias
        // Este m√©todo existe para futuras funcionalidades que precisem
        // de atualiza√ß√£o constante (anima√ß√µes, etc.)
    }

    /**
     * Aplica um efeito de "shake" na tela
     * √ötil para feedback visual quando algo importante acontece
     * @param intensity Intensidade do shake (1-10)
     * @param duration Dura√ß√£o em milissegundos
     */
    public screenShake(intensity: number = 5, duration: number = 300): void {
        const gameUI = document.getElementById('gameUI');
        if (!gameUI) return;
        
        console.log(`üì≥ Screen shake: intensidade ${intensity}, dura√ß√£o ${duration}ms`);
        
        const originalTransform = gameUI.style.transform;
        const startTime = performance.now();
        
        const shake = () => {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;
            
            if (progress >= 1) {
                // Shake completo - voltar ao normal
                gameUI.style.transform = originalTransform;
                return;
            }
            
            // Calcular offset aleat√≥rio baseado na intensidade
            const currentIntensity = intensity * (1 - progress); // Diminui com o tempo
            const offsetX = (Math.random() - 0.5) * currentIntensity;
            const offsetY = (Math.random() - 0.5) * currentIntensity;
            
            gameUI.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            
            // Continuar shake
            requestAnimationFrame(shake);
        };
        
        shake();
    }

    /**
     * Reinicia todos os elementos da UI para o estado inicial
     */
    public reset(): void {
        console.log('üîÑ Reiniciando UI...');
        
        // Esconder barra de casting se estiver vis√≠vel
        if (this.isCastingBarVisible) {
            this.hideCastingBar();
        }
        
        // Resetar contadores
        this.updateSpellCount(0);
        
        console.log('‚úÖ UI reiniciada!');
    }

    /**
     * Limpa recursos da UI quando o jogo √© fechado
     */
    public dispose(): void {
        console.log('üßπ Limpando recursos da UI...');
        
        // Esconder barra de casting se estiver vis√≠vel
        if (this.isCastingBarVisible) {
            this.hideCastingBar();
        }
        
        // Remover quaisquer notifica√ß√µes ativas
        const notifications = document.querySelectorAll('.notification');
        notifications.forEach(notification => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        });
        
        console.log('‚úÖ UI limpa!');
    }
}